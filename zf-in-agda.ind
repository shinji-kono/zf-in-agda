-title: Constructing ZF Set Theory in Agda 

--author: Shinji KONO

--Programming Mathematics

Programming is processing data structure with Î» terms.

We are going to handle Mathematics in intuitionistic logic with Î» terms.

Mathematics is a functional programming which values are proofs.

Programming ZF Set Theory in Agda

--Target

   Describe ZF axioms in Agda
   Construction a Model of ZF Set Theory in Agda
   Show necessary assumptions for the model
   Show validities of ZF axioms on the model

This shows consistency of Set Theory (with some assumptions),
without circulating ZF Theory assumption.

<a href="https://github.com/shinji-kono/zf-in-agda">
ZF in Agda https://github.com/shinji-kono/zf-in-agda
</a>

--Why Set Theory

If we can formulate Set theory, it suppose to work on any mathematical theory.

Set Theory is a difficult point for beginners especially axiom of choice.

It has some amount of difficulty and self circulating discussion.

I'm planning to do it in my old age, but I'm enough age now.

This is done during from May to September.

--Agda and Intuitionistic Logic 

Curry Howard Isomorphism

    Proposition : Proof â‡” Type : Value

which means

ã€€ã€€constructing a typed lambda calculus which corresponds a logic

Typed lambda calculus which allows complex type as a value of a variable (System FC)

ã€€ã€€First class Type / Dependent Type

Agda is a such a programming language which has similar syntax of Haskell

Coq is specialized in proof assistance such as command and tactics .

--Introduction of Agda 

A length of a list of type A.

    length : {A : Set } â†’ List A â†’ Nat
    length [] = zero
    length (_ âˆ· t)  = suc ( length t )

Simple functional programming language. Type declaration is mandatory.
A colon means type, an equal means value. Indentation based.

Set is a base type (which may have a level ).

{} means implicit variable which can be omitted if Agda infers its value.

--data ( Sum type )

A data type which as exclusive multiple constructors. A similar one as
union in C or case class in Scala.

It has a similar syntax as Haskell but it has a slight difference.

   data List (A : Set ) : Set where
        [] : List A
        _âˆ·_ : A â†’ List A â†’ List A

_âˆ·_ means infix operator. If use explicit _, it can be used in a normal function
syntax.

Natural number can be defined as a usual way.

   data Nat : Set where
        zero : Nat
        suc  : Nat â†’ Nat

-- A â†’ B means "A implies B"

In Agda, a type can be a value of a variable, which is usually called dependent type.
Type has a name Set in Agda.

    ex3 : {A B : Set} â†’ Set 
    ex3 {A}{B}  =  A â†’ B

ex3 is a type : A â†’ B, which is a value of Set. It also means a formula : A implies B.

    A type is a formula, the value is the proof

A value of A â†’ B can be interpreted as an inference from the formula A to the formula B, which
can be a function from a proof of A to a proof of B.

--introduction ã¨ elimination

For a logical operator, there are two types of inference, an introduction and an elimination.

  intro creating symbol  / constructor / introduction
  elim  using symbolic / accessors / elimination

In Natural deduction, this can be written in proof schema.

       A                   
       :
       B                    A       A â†’ B
   ------------- â†’intro   ------------------ â†’elim
      A â†’ B                     B

In Agda, this is a pair of type and value as follows. Introduction of â†’ uses Î».

    â†’intro : {A B : Set } â†’ A â†’  B â†’ ( A â†’ B )
    â†’intro _ b = Î» x â†’ b

    â†’elim : {A B : Set } â†’ A â†’ ( A â†’ B ) â†’ B
    â†’elim a f = f a

Important

    {A B : Set } â†’ A â†’  B â†’ ( A â†’ B )

is

    {A B : Set } â†’ ( A â†’  ( B â†’ ( A â†’ B ) ))

This makes currying of function easy.

-- To prove A â†’ B 

Make a left type as an argument. (intros in Coq)

    ex5 : {A B C : Set } â†’ A â†’ B â†’ C  â†’ ?
    ex5 a b c = ?

? is called a hole, which is unspecified part. Agda tell us which kind type is required for the Hole.

We are going to fill the holes, and if we have no warnings nor errors such as type conflict (Red),
insufficient proof or instance (Yellow), Non-termination, the proof is completed.

-- A âˆ§ B

Well known conjunction's introduction and elimination is as follow.

     A    B                 A âˆ§ B           A âˆ§ B 
   -------------         ----------- proj1   ---------- proj2
      A âˆ§ B                   A               B

We can introduce a corresponding structure in our functional programming language.

-- record

   record _âˆ§_ A B : Set
     field
         proj1 : A
         proj2 : B

_âˆ§_ã€€means infix operator.  _âˆ§_ A B can be written as  A âˆ§  B (Haskell uses (âˆ§) )

This a type which constructed from type A and type B. You may think this as an object
or struct.

   record { proj1 = x ; proj2 = y }    

is a constructor of _âˆ§_.

    ex3 : {A B : Set} â†’ A â†’ B â†’ ( A âˆ§ B )
    ex3 a b = record { proj1 = a ; proj2 = b }

    ex1 : {A B : Set} â†’ ( A âˆ§ B ) â†’ A
    ex1 aâˆ§b = proj1 aâˆ§b

aâˆ§b is a variable name. If we have no spaces in a string, it is a word even if we have symbols
except parenthesis or colons. A symbol requires space separation such as a type defining colon.

Defining record can be recursively, but we don't use the recursion here.

-- Mathematical structure

We have types of elements and the relationship in a mathematical structure.

  logical relation has no ordering
  there is a natural ordering in arguments and a value in a function

So we have typical definition style of mathematical structure with records.

  record IsOrdinals {n : Level} (ord : Set n)  
    (_o<_ : ord â†’ ord â†’ Set n) : Set (suc (suc n)) where
   field
     Otrans :  {x y z : ord }  â†’ x o< y â†’ y o< z â†’ x o< z

  record Ordinals {n : Level} : Set (suc (suc n)) where
       field 
         ord : Set n
         _o<_ : ord â†’ ord â†’ Set n
         isOrdinal : IsOrdinals ord _o<_

In IsOrdinals, axioms are written in flat way. In Ordinal, we may have
inputs and outputs are put in the field including IsOrdinal.

Fields of Ordinal is existential objects in the mathematical structure.

-- A Model and a theory

Agda record is a type, so we can write it in the argument, but is it really exists?

If we have a value of the record, it simply exists, that is, we need to create all the existence
in the record satisfies all the axioms (= field of IsOrdinal) should be valid.

   type of record = theory
   value of record = model

We call the value of the record as a model. If mathematical structure has a
model, it exists. Pretty Obvious.

-- postulate ã¨ module

Agda proofs are separated by modules, which are large records.

postulates are assumptions. We can assume a type without proofs.

    postulate      
      sup-o  :  ( Ordinal  â†’ Ordinal ) â†’  Ordinal 
      sup-o< :  { Ïˆ : Ordinal  â†’  Ordinal } â†’ âˆ€ {x : Ordinal } â†’ Ïˆ x  o<  sup-o Ïˆ 

sup-o is an example of upper bound of a function and sup-o< assumes it actually 
satisfies all the value is less than upper bound.

Writing some type in a module argument is the same as postulating a type, but
postulate can be written the middle of a proof.

postulate can be constructive.

postulate can be inconsistent, which result everything has a proof.

-- A âˆ¨ B

    data _âˆ¨_ (A B : Set) : Set where
      case1 : A â†’ A âˆ¨ B
      case2 : B â†’ A âˆ¨ B

As Haskell, case1/case2 are  patterns.

    ex3 : {A B : Set} â†’ ( A âˆ¨ A ) â†’ A 
    ex3 = ?

In a case statement, Agda command C-C C-C generates possible cases in the head.

    ex3 : {A B : Set} â†’ ( A âˆ¨ A ) â†’ A 
    ex3 (case1 x) = ?
    ex3 (case2 x) = ?

Proof schema of âˆ¨ is omit due to the complexity.

-- Negation

       âŠ¥
    ------------- âŠ¥-elim
       A

Anything can be derived from bottom, in this case a Set A. There is no introduction rule
in âŠ¥, which can be implemented as data which has no constructor.

    data âŠ¥ : Set where

âŠ¥-elim can be proved like this.

    âŠ¥-elim : {A : Set } -> âŠ¥ -> A
    âŠ¥-elim ()

() means no match argument nor value.

A negation can be defined using âŠ¥ like this.

    Â¬_ : Set â†’ Set
    Â¬ A = A â†’ âŠ¥

--Equality 

All the value in Agda are terms. If we have the same normalized form, two terms are equal.
If we have variables in the terms, we will perform an unification. unifiable terms are equal.
We don't go further on the unification.

     { x : A }                 x â‰¡ y    f x y
   --------------- â‰¡-intro   --------------------- â‰¡-elim
      x â‰¡ x                         f x x

equality _â‰¡_  can be defined as a data.

    data _â‰¡_ {A : Set } : A â†’ A â†’ Set where
       refl :  {x : A} â†’ x â‰¡ x

The elimination of equality is a substitution in a term.

    subst : {A : Set } â†’ { x y : A } â†’ ( f : A â†’ Set ) â†’ x â‰¡ y â†’ f x â†’ f y
    subst {A} {x} {y} f refl fx = fx

    ex5 :   {A : Set} {x y z : A } â†’  x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
    ex5 {A} {x} {y} {z} xâ‰¡y yâ‰¡z = subst ( Î» k â†’ x â‰¡ k ) yâ‰¡z xâ‰¡y


--Equivalence relation

    refl' : {A : Set} {x : A } â†’ x â‰¡ x
    refl'  = ?
    sym : {A : Set} {x y : A } â†’ x â‰¡ y â†’ y â‰¡ x
    sym = ?
    trans : {A : Set} {x y z : A } â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
    trans = ?
    cong : {A B : Set} {x y : A } { f : A â†’ B } â†’   x â‰¡ y â†’ f x â‰¡ f y
    cong = ?

--Ordering

Relation is a predicate on two value which has a same type.

   A â†’ A â†’ Set 

Defining order is the definition of this type with predicate or a data.

    data _â‰¤_ : Rel â„• 0â„“ where
      zâ‰¤n : âˆ€ {n}                 â†’ zero  â‰¤ n
      sâ‰¤s : âˆ€ {m n} (mâ‰¤n : m â‰¤ n) â†’ suc m â‰¤ suc n


--Quantifier

Handling quantifier in an intuitionistic logic requires special cares.

In the input of a function, there are no restriction on it, that is, it has
a universal quantifier. (If we explicitly write âˆ€, Agda gives us a type inference on it)

There is no âˆƒ in agda, the one way is using negation like this.

ã€€âˆƒ (x : A ) â†’ p x  = Â¬ ( ( x : A ) â†’ Â¬ ( p x ) )

On the another way, f : A can be used like this.

  p f

If we use a function which can be defined globally which has stronger meaning the
usage of âˆƒ x in a logical expression.


--Can we do math in this way?

Yes, we can. Actually we have Principia Mathematica by Russell and Whitehead (with out computer support).

In some sense, this story is a reprinting of the work, (but Principia Mathematica has a different formulation than ZF).

    define mathematical structure as a record
    program inferences as if we have proofs in variables

--Things which Agda cannot prove

The infamous Internal Parametricity is a limitation of Agda, it cannot prove so called Free Theorem, which
leads uniqueness of a functor in Category Theory.

Functional extensionality cannot be proved.
  (âˆ€ x â†’ f x â‰¡ g x) â†’ f â‰¡ g

Agda has no law of exclude middle.

  a âˆ¨ ( Â¬ a )

For example, (A â†’ B) â†’ Â¬ B â†’ Â¬ A can be proved but, ( Â¬ B â†’ Â¬ A ) â†’ A â†’ B cannot.

It also other problems such as termination, type inference or unification which we may overcome with
efforts or devices or may not.

If we cannot prove something, we can safely postulate it unless it leads a contradiction.
 
--Classical story of ZF Set Theory

Assuming ZF, constructing  a model of ZF is a flow of classical Set Theory, which leads
a relative consistency proof of the Set Theory.
Ordinal number is used in the flow. 

In Agda, first we defines Ordinal numbers (Ordinals), then introduce Ordinal Definable Set (OD).
We need some non constructive assumptions in the construction. A model of Set theory is
constructed based on these assumptions.

<center><img src="fig/set-theory.svg"></center>

--Ordinals

Ordinals are our intuition of infinite things, which has âˆ… and orders on the things.
It also has a successor osuc.

    record Ordinals {n : Level} : Set (suc (suc n)) where
       field
         ord : Set n
         oâˆ… : ord
         osuc : ord â†’ ord
         _o<_ : ord â†’ ord â†’ Set n
         isOrdinal : IsOrdinals ord oâˆ… osuc _o<_

It is different from natural numbers in way. The order of Ordinals is not defined in terms
of successor. It is given from outside, which make it possible to have higher order infinity.

--Axiom of Ordinals

Properties of infinite things. We request a transfinite induction, which states that if
some properties are satisfied below all possible ordinals, the properties are true on all
ordinals.

Successor osuc has no ordinal between osuc and the base ordinal. There are some ordinals
which is not a successor of any ordinals. It is called limit ordinal.

Any two ordinal can be compared, that is less, equal or more, that is total order.

  record IsOrdinals {n : Level} (ord : Set n)  (oâˆ… : ord ) 
    (osuc : ord â†’ ord )  
    (_o<_ : ord â†’ ord â†’ Set n) : Set (suc (suc n)) where
   field
     Otrans :  {x y z : ord }  â†’ x o< y â†’ y o< z â†’ x o< z
     OTri : Trichotomous {n} _â‰¡_  _o<_ 
     Â¬x<0 :   { x  : ord  } â†’ Â¬ ( x o< oâˆ…  )
     <-osuc :  { x : ord  } â†’ x o< osuc x
     osuc-â‰¡< :  { a x : ord  } â†’ x o< osuc a  â†’  (x â‰¡ a ) âˆ¨ (x o< a)  
     TransFinite : { Ïˆ : ord  â†’ Set (suc n) }
          â†’ ( (x : ord)  â†’ ( (y : ord  ) â†’ y o< x â†’ Ïˆ y ) â†’ Ïˆ x )
          â†’  âˆ€ (x : ord)  â†’ Ïˆ x

--Concrete Ordinals

We can define a list like structure with level, which is a kind of two dimensional infinite array.

    data OrdinalD {n : Level} :  (lv : Nat) â†’ Set n where
       Î¦ : (lv : Nat) â†’ OrdinalD  lv
       OSuc : (lv : Nat) â†’ OrdinalD {n} lv â†’ OrdinalD lv

The order of the OrdinalD can be defined in this way.

    data _d<_ {n : Level} :   {lx ly : Nat} â†’ OrdinalD {n} lx  â†’  OrdinalD {n} ly  â†’ Set n where
       Î¦<  : {lx : Nat} â†’ {x : OrdinalD {n} lx}  â†’  Î¦ lx d< OSuc lx x
       s<  : {lx : Nat} â†’ {x y : OrdinalD {n} lx}  â†’  x d< y  â†’ OSuc  lx x d< OSuc  lx y

This is a simple data structure, it has no abstract assumptions, and it is countable many data
structure.

   Î¦ 0
   OSuc 2 ( Osuc 2 ( Osuc 2 (Î¦ 2)))
   Osuc 0 (Î¦ 0) d< Î¦ 1

--Model of Ordinals

It is easy to show OrdinalD and its order satisfies the axioms of Ordinals.

So our Ordinals has a mode. This means axiom of Ordinals are consistent.

--Debugging axioms using Model

Whether axiom is correct or not can be checked by a validity on a mode.

If not, we may fix the axioms or the model, such as the definitions of the order.

We can also ask whether the inputs exist.

--Countable Ordinals can contains uncountable set?

Yes, the ordinals contains any level of infinite Set in the axioms.

If we handle real-number in the model, only countable number of real-number is used.

    from the outside view point, it is countable
    from the internal view point, it is uncountable

The definition of countable/uncountable is the same, but the properties are different
depending on the context.

We don't show the definition of cardinal number here.

--What is Set

The word Set in Agda is not a Set of ZF Set, but it is a type (why it is named Set?).

From naive point view, a set i a list, but in Agda, elements have all the same type.
A set in ZF may contain other Sets in ZF, which not easy to implement it as a list.

Finite set may be written in finite series of âˆ¨, but ...

--We don't ask the contents of Set. It can be anything.

From empty set Ï†, we can think a set contains a Ï†, and a pair of Ï† and the set, and so on,
and all of them, and again we repeat this.

   Ï† {Ï†} {Ï†,{Ï†}}, {Ï†,{Ï†},...}

It is called V.

This operation can be performed within a ZF Set theory. Classical Set Theory assumes
ZF, so this kind of thing is allowed.

But in our case, we have no ZF theory, so we are going to use Ordinals.


--Ordinal Definable Set

We can define a sbuset of Ordinals using predicates. What is a subset?

   a predicate has an Ordinal argument

is an Ordinal Definable Set (OD). In Agda, OD is defined as follows.

    record OD : Set (suc n ) where
      field
        def : (x : Ordinal  ) â†’ Set n

Ordinals itself is not a set in a ZF Set theory but a class. In OD, 

   record { def = Î» x â†’ true }

means Ordinals itself, so ODs are larger than a notion of ZF Set Theory,
but we don't care about it.


--âˆ‹ in OD

OD is a predicate on Ordinals and it does not contains OD directly. If we have a mapping

      odâ†’ord : OD  â†’ Ordinal 

we may check an OD is an element of the OD using def.

A âˆ‹ x can be define as follows.

    _âˆ‹_ : ( A x : OD  ) â†’ Set n
    _âˆ‹_  A x  = def A ( odâ†’ord x )

In Ïˆ : Ordinal â†’ Set,  if A is a  record { def = Î» x â†’ Ïˆ x } , then

    A x = def A ( odâ†’ord x ) = Ïˆ (odâ†’ord x)

--1 to 1 mapping between an OD and an Ordinal

  odâ†’ord : OD  â†’ Ordinal 
  ordâ†’od : Ordinal  â†’ OD  
  oiso   :  {x : OD }      â†’ ordâ†’od ( odâ†’ord x ) â‰¡ x
  diso   :  {x : Ordinal } â†’ odâ†’ord ( ordâ†’od x ) â‰¡ x

They say the existing of the mappings can be proved in Classical Set Theory, but we
simply assumes these non constructively.

We use postulate, it may contains additional restrictions which are not clear now. 
It look like the mapping should be a subset of Ordinals, but we don't explicitly
state it.

<center><img src="fig/ord-od-mapping.svg"></center>

--Order preserving in the mapping of OD and Ordinal

Ordinals have the order and OD has a natural order based on inclusion ( def / âˆ‹ ).

     def y ( odâ†’ord x )

An elements of OD should be defined before the OD, that is, an ordinal corresponding an elements
have to be smaller than the corresponding ordinal of the containing OD.

  c<â†’o<  :  {x y : OD  }   â†’ def y ( odâ†’ord x ) â†’ odâ†’ord x o< odâ†’ord y

This is also said to be provable in classical Set Theory, but we simply assumes it.

OD has an order based on the corresponding ordinal, but it may not have corresponding def / âˆ‹
relation. This means the reverse order preservation, 

  o<â†’c<  : {n : Level} {x y : Ordinal  } â†’ x o< y â†’ def (ordâ†’od y) x 

is not valid. If we assumes it, âˆ€ x âˆ‹ âˆ… becomes true, which manes all OD becomes Ordinals in
the model.

<center><img src="fig/ODandOrdinals.svg"></center>

--ISO

It also requires isomorphisms, 

  oiso   :  {x : OD }      â†’ ordâ†’od ( odâ†’ord x ) â‰¡ x
  diso   :  {x : Ordinal } â†’ odâ†’ord ( ordâ†’od x ) â‰¡ x


--Various Sets

In classical Set Theory, there is a hierarchy call L, which can be defined by a predicate.

    Ordinal / things satisfies axiom of Ordinal / extension of natural number 
    V / hierarchical construction of Set from Ï†   
    L / hierarchical predicate definable construction of Set from Ï†   
    OD / equational formula on Ordinals 
    Agda Set / Type / it also has a level


--Fixes on ZF to intuitionistic logic

We use ODs as Sets in ZF, and defines record ZF, that is, we have to define
ZF axioms in Agda.

It may not valid in our model. We have to debug it.

Fixes are depends on axioms.

<center><img src="fig/axiom-type.svg"></center>

<a href="fig/zf-record.html">
ZFã®record 
</a>

--Pure logical axioms

   empty, pair, select, Îµ-induction€infinity

These are logical relations among OD.

     empty :  âˆ€( x : ZFSet  ) â†’ Â¬ ( âˆ… âˆ‹ x )
     pairâ†’ : ( x y t : ZFSet  ) â†’  (x , y)  âˆ‹ t  â†’ ( t â‰ˆ x ) âˆ¨ ( t â‰ˆ y ) 
     pairâ† : ( x y t : ZFSet  ) â†’  ( t â‰ˆ x ) âˆ¨ ( t â‰ˆ y )  â†’  (x , y)  âˆ‹ t 
     selection : { Ïˆ : ZFSet â†’ Set m } â†’ âˆ€ { X y : ZFSet  } â†’  ( ( y âˆˆ X ) âˆ§ Ïˆ y ) â‡” (y âˆˆ  Select X Ïˆ ) 
     infinityâˆ… :  âˆ… âˆˆ infinite
     infinity :  âˆ€( x : ZFSet  ) â†’ x âˆˆ infinite â†’  ( x âˆª ( x , x ) ) âˆˆ infinite 
     Îµ-induction : { Ïˆ : OD  â†’ Set (suc n)}
       â†’ ( {x : OD } â†’ ({ y : OD } â†’  x âˆ‹ y â†’ Ïˆ y ) â†’ Ïˆ x )
       â†’ (x : OD ) â†’ Ïˆ x

finitely can be define by Agda data.

    data infinite-d  : ( x : Ordinal  ) â†’ Set n where
        iÏ† :  infinite-d oâˆ…
        isuc : {x : Ordinal  } â†’   infinite-d  x  â†’
                infinite-d  (odâ†’ord ( Union (ordâ†’od x , (ordâ†’od x , ordâ†’od x ) ) ))

Union (x , ( x , x )) should be an direct successor of x, but we cannot prove it in our model.

--Axiom of Pair

In the Tanaka's book, axiom of pair is as follows.

     âˆ€ x âˆ€ y âˆƒ z âˆ€ t ( z âˆ‹ t â†” t â‰ˆ x âˆ¨ t â‰ˆ y)

We have fix âˆƒ z, a function (x , y) is defined, which is  _,_ .

     _,_ : ( A B : ZFSet  ) â†’ ZFSet

using this, we can define two directions in separates axioms, like this.

     pairâ†’ : ( x y t : ZFSet  ) â†’  (x , y)  âˆ‹ t  â†’ ( t â‰ˆ x ) âˆ¨ ( t â‰ˆ y ) 
     pairâ† : ( x y t : ZFSet  ) â†’  ( t â‰ˆ x ) âˆ¨ ( t â‰ˆ y )  â†’  (x , y)  âˆ‹ t 

This is already written in Agda, so we use these as axioms. All inputs have âˆ€.

--pair in OD

OD is an equation on Ordinals, we can simply write axiom of pair in the OD.

    _,_ : OD  â†’ OD  â†’ OD 
    x , y = record { def = Î» t â†’ (t â‰¡ odâ†’ord x ) âˆ¨ ( t â‰¡ odâ†’ord y ) } 

â‰¡ is an equality of Î» terms, but please not that this is equality on Ordinals.

--Validity of Axiom of Pair

Assuming ZFSet is OD, we are going to prove pairâ†’ .

    pairâ†’ : ( x y t : OD  ) â†’  (x , y)  âˆ‹ t  â†’ ( t == x ) âˆ¨ ( t == y ) 
    pairâ†’ x y t p = ?

In this program, type of p is ( x , y ) âˆ‹ t , that is 
def ( x , y ) that is, (t â‰¡ odâ†’ord x ) âˆ¨ ( t â‰¡ odâ†’ord y ) .

Since _âˆ¨_ is a data, it can be developed as (C-c C-c : agda2-make-case ).

    pairâ†’ x y t (case1 tâ‰¡x ) = ?
    pairâ†’ x y t (case2 tâ‰¡y ) = ?

The type of the ? is ( t == x ) âˆ¨ ( t == y ), again it is  data _âˆ¨_ .

    pairâ†’ x y t (case1 tâ‰¡x ) = case1 ?
    pairâ†’ x y t (case2 tâ‰¡y ) = case2 ?

The ? in case1 is t == x, so we have to create this from tâ‰¡x, which is a name of a variable
which type is 

    tâ‰¡x : odâ†’ord t â‰¡ odâ†’ord x

which is shown by an Agda command (C-C C-E : agda2-show-context ).

But we haven't defined == yet.

--Equality of OD and Axiom of Extensionality 

OD is defined by a predicates, if we compares normal form of the predicates, even if
it contains the same elements, it may be different, which is no good as an equality of
Sets.

Axiom of Extensionality requires sets having the same elements are handled in the same way
each other.

    âˆ€ z ( z âˆˆ x â‡” z âˆˆ y ) â‡’ âˆ€ w ( x âˆˆ w â‡” y âˆˆ w )

We can write this axiom in Agda as follows.

     extensionality :  { A B w : ZFSet  } â†’ ( (z : ZFSet) â†’ ( A âˆ‹ z ) â‡” (B âˆ‹ z)  ) â†’ ( A âˆˆ w â‡” B âˆˆ w )

So we use ( A âˆ‹ z ) â‡” (B âˆ‹ z) as an equality (_==_) of our model. We have to show
A âˆˆ w â‡” B âˆˆ w from A == B.

x ==  y can be defined in this way.

    record _==_  ( a b :  OD  ) : Set n where
      field
         eqâ†’ : âˆ€ { x : Ordinal  } â†’ def a x â†’ def b x
         eqâ† : âˆ€ { x : Ordinal  } â†’ def b x â†’ def a x

Actually, (z : OD) â†’ (A âˆ‹ z) â‡” (B âˆ‹ z) implies A == B.

    extensionality0 : {A B : OD } â†’ ((z : OD) â†’ (A âˆ‹ z) â‡” (B âˆ‹ z)) â†’ A == B
    eqâ†’ (extensionality0 {A} {B} eq ) {x} d = ?
    eqâ† (extensionality0 {A} {B} eq ) {x} d = ?

? are def B x and def A x and these are generated from  eq : (z : OD) â†’ (A âˆ‹ z) â‡” (B âˆ‹ z) .

Actual proof is rather complicated.

   eqâ†’ (extensionality0 {A} {B} eq ) {x} d = def-iso  {A} {B} (sym diso) (proj1 (eq (ordâ†’od x))) d
   eqâ† (extensionality0 {A} {B} eq ) {x} d = def-iso  {B} {A} (sym diso) (proj2 (eq (ordâ†’od x))) d

where

   def-iso : {A B : OD } {x y : Ordinal } â†’ x â‰¡ y  â†’ (def A y â†’ def B y)  â†’ def A x â†’ def B x
   def-iso refl t = t

--Validity of Axiom of Extensionality

If we can derive (w âˆ‹ A) â‡” (w âˆ‹ B) from A == B, the axiom becomes valid, but it seems impossible, 
so we assumes

  ==â†’oâ‰¡ : { x y : OD  } â†’ (x == y) â†’ x â‰¡ y

Using this, we have

    extensionality : {A B w : OD  } â†’ ((z : OD ) â†’ (A âˆ‹ z) â‡” (B âˆ‹ z)) â†’ (w âˆ‹ A) â‡” (w âˆ‹ B)
    proj1 (extensionality {A} {B} {w} eq ) d = subst (Î» k â†’ w âˆ‹ k) ( ==â†’oâ‰¡ (extensionality0 {A} {B} eq) ) d
    proj2 (extensionality {A} {B} {w} eq ) d = subst (Î» k â†’ w âˆ‹ k) (sym ( ==â†’oâ‰¡ (extensionality0 {A} {B} eq) )) d

This assumption means we may have an equivalence set on any predicates.

--Non constructive assumptions so far

We have correspondence between OD and Ordinals and one directional order preserving.

We also have equality assumption.

  odâ†’ord : OD  â†’ Ordinal
  ordâ†’od : Ordinal  â†’ OD
  oiso   :  {x : OD }      â†’ ordâ†’od ( odâ†’ord x ) â‰¡ x
  diso   :  {x : Ordinal } â†’ odâ†’ord ( ordâ†’od x ) â‰¡ x
  c<â†’o<  :  {x y : OD  }   â†’ def y ( odâ†’ord x ) â†’ odâ†’ord x o< odâ†’ord y
  ==â†’oâ‰¡ : { x y : OD  } â†’ (x == y) â†’ x â‰¡ y


--Axiom which have negation form

   Union, Selection

These axioms contains âˆƒ x as a logical relation, which can be described in Â¬ ( âˆ€ x ( Â¬ p )).

Axiom of replacement uses upper bound of function on Ordinals, which makes it non-constructive.

Power Set axiom requires double negation, 

     powerâ†’ : âˆ€( A t : ZFSet  ) â†’ Power A âˆ‹ t â†’ âˆ€ {x}  â†’  t âˆ‹ x â†’ Â¬ Â¬ ( A âˆ‹ x ) 
     powerâ† : âˆ€( A t : ZFSet  ) â†’ t âŠ†_ A â†’ Power A âˆ‹ t 

If we have an assumption of law of exclude middle, we can recover the original A âˆ‹ x form.

--Union 

The original form of the Axiom of Union is

     âˆ€ x âˆƒ y âˆ€ z (z âˆˆ y â‡” âˆƒ u âˆˆ x  âˆ§ (z âˆˆ u))

Union requires the existence of b in  a âŠ‡ âˆƒ b âˆ‹ x . We will use negation form of âˆƒ.

     unionâ†’ : ( X z u : ZFSet ) â†’ ( X âˆ‹ u ) âˆ§ (u âˆ‹ z ) â†’ Union X âˆ‹ z
     unionâ† : ( X z : ZFSet ) â†’ (Xâˆ‹z : Union X âˆ‹ z ) â†’  Â¬  ( (u : ZFSet ) â†’ Â¬ ((X âˆ‹  u) âˆ§ (u âˆ‹ z )))

The definition of Union in OD is like this.

    Union : OD  â†’ OD   
    Union U = record { def = Î» x â†’ Â¬ (âˆ€ (u : Ordinal ) â†’ Â¬ ((def U u) âˆ§ (def (ordâ†’od u) x)))  }

Proof of validity is straight forward.

         unionâ†’ :  (X z u : OD) â†’ (X âˆ‹ u) âˆ§ (u âˆ‹ z) â†’ Union X âˆ‹ z
         unionâ†’ X z u xx not = âŠ¥-elim ( not (odâ†’ord u) ( record { proj1 = proj1 xx
              ; proj2 = subst ( Î» k â†’ def k (odâ†’ord z)) (sym oiso) (proj2 xx) } ))
         unionâ† :  (X z : OD) (Xâˆ‹z : Union X âˆ‹ z) â†’  Â¬  ( (u : OD ) â†’ Â¬ ((X âˆ‹  u) âˆ§ (u âˆ‹ z )))
         unionâ† X z UXâˆ‹z =  FExists _ lemma UXâˆ‹z where
              lemma : {y : Ordinal} â†’ def X y âˆ§ def (ordâ†’od y) (odâ†’ord z) â†’ Â¬ ((u : OD) â†’ Â¬ (X âˆ‹ u) âˆ§ (u âˆ‹ z))
              lemma {y} xx not = not (ordâ†’od y) record { proj1 = subst ( Î» k â†’ def X k ) (sym diso) (proj1 xx ) ; proj2 = proj2 xx }

where

        FExists : {m l : Level} â†’ ( Ïˆ : Ordinal  â†’ Set m )
          â†’ {p : Set l} ( P : { y : Ordinal  } â†’  Ïˆ y â†’ Â¬ p )
          â†’ (exists : Â¬ (âˆ€ y â†’ Â¬ ( Ïˆ y ) ))
          â†’ Â¬ p
        FExists  {m} {l} Ïˆ {p} P = contra-position ( Î» p y Ïˆy â†’ P {y} Ïˆy p )

which checks existence using contra-position.

--Axiom of replacement

We can replace the elements of a set by a function and it becomes a set. From the book, 

     âˆ€ x âˆ€ y âˆ€ z ( ( Ïˆ ( x , y ) âˆ§ Ïˆ ( x , z ) ) â†’ y = z ) â†’ âˆ€ X âˆƒ A âˆ€ y ( y âˆˆ A â†” âˆƒ x âˆˆ X Ïˆ ( x , y ) )

The existential quantifier can be related by a function, 

     Replace : OD  â†’ (OD  â†’ OD  ) â†’ OD

The axioms becomes as follows.

     replacementâ† : {Ïˆ : ZFSet â†’ ZFSet} â†’ âˆ€ ( X x : ZFSet  ) â†’ x âˆˆ X â†’ Ïˆ x âˆˆ  Replace X Ïˆ
     replacementâ†’ : {Ïˆ : ZFSet â†’ ZFSet} â†’ âˆ€ ( X x : ZFSet  ) â†’  ( lt : x âˆˆ  Replace X Ïˆ ) â†’ Â¬ ( âˆ€ (y : ZFSet)  â†’  Â¬ ( x â‰ˆ Ïˆ y ) )

In the axiom, the existence of the original elements is necessary. In order to do that we use OD which has
negation form of existential quantifier in the definition.

    in-codomain : (X : OD  ) â†’ ( Ïˆ : OD  â†’ OD  ) â†’ OD 
    in-codomain  X Ïˆ = record { def = Î» x â†’ Â¬ ( (y : Ordinal ) â†’ Â¬ ( def X y âˆ§  ( x â‰¡ odâ†’ord (Ïˆ (ordâ†’od y )))))  }

Besides this upper bounds is required.

    Replace : OD  â†’ (OD  â†’ OD  ) â†’ OD 
    Replace X Ïˆ = record { def = Î» x â†’ (x o< sup-o  ( Î» x â†’ odâ†’ord (Ïˆ (ordâ†’od x )))) âˆ§ def (in-codomain X Ïˆ) x }

We omit the proof of the validity, but it is rather straight forward.

--Validity of Power Set Axiom

The original Power Set Axiom is this.

     âˆ€ X âˆƒ A âˆ€ t ( t âˆˆ A â†” t âŠ† X ) )

The existential quantifier is replaced by a function

    Power : ( A : OD  ) â†’ OD

t âŠ† X is a  record like this.

    record _âŠ†_ ( A B : OD   ) : Set (suc n) where
      field
         incl : { x : OD } â†’ A âˆ‹ x â†’  B âˆ‹ x

Axiom becomes likes this.

    powerâ†’ :  ( A t : OD) â†’ Power A âˆ‹ t â†’ {x : OD} â†’ t âˆ‹ x â†’ Â¬ Â¬ (A âˆ‹ x)
    powerâ† :  (A t : OD) â†’ ({x : OD} â†’ (t âˆ‹ x â†’ A âˆ‹ x)) â†’ Power A âˆ‹ t

The validity of the axioms are slight complicated, we have to define set of all subset. We define
subset in a different form.

    ZFSubset : (A x : OD  ) â†’ OD 
    ZFSubset A x =  record { def = Î» y â†’ def A y âˆ§  def x y }  

We can prove, 

    ( {y : OD } â†’ x âˆ‹ y â†’ ZFSubset A x âˆ‹  y ) â‡”  ( x âŠ† A  ) 

We only have upper bound as an ordinal, but we have an obvious OD based on the order of Ordinals,
which is an Ordinals with our Model.

    Ord : ( a : Ordinal  ) â†’ OD 
    Ord  a = record { def = Î» y â†’ y o< a }  

    Def :  (A :  OD ) â†’ OD 
    Def  A = Ord ( sup-o  ( Î» x â†’ odâ†’ord ( ZFSubset A (ordâ†’od x )) ) )   

This is slight larger than Power A, so we replace all elements x by A âˆ© x (some of them may empty).

    Power : OD  â†’ OD 
    Power A = Replace (Def (Ord (odâ†’ord A))) ( Î» x â†’ A âˆ© x )

Creating Power Set of Ordinals is rather easy, then we use replacement axiom on A âˆ© x since we have this.

     âˆ©-â‰¡ :  { a b : OD  } â†’ ({x : OD  } â†’ (a âˆ‹ x â†’ b âˆ‹ x)) â†’ a == ( b âˆ© a )

In case of Ord a  intro of Power Set axiom becomes valid.

    ord-powerâ† : (a : Ordinal ) (t : OD) â†’ ({x : OD} â†’ (t âˆ‹ x â†’ (Ord a) âˆ‹ x)) â†’ Def (Ord a) âˆ‹ t

Using this, we can prove,

         powerâ†’ :  ( A t : OD) â†’ Power A âˆ‹ t â†’ {x : OD} â†’ t âˆ‹ x â†’ Â¬ Â¬ (A âˆ‹ x)
         powerâ† :  (A t : OD) â†’ ({x : OD} â†’ (t âˆ‹ x â†’ A âˆ‹ x)) â†’ Power A âˆ‹ t


--Axiom of regularity, Axiom of choice, Îµ-induction

Axiom of regularity requires non self intersectable elements (which is called minimum), if we
replace it by a function, it becomes a choice function. It makes axiom of choice valid.

This means we cannot prove axiom regularity form our model, and if we postulate this, axiom of
choice also becomes valid.

  minimal : (x : OD  ) â†’ Â¬ (x == odâˆ… )â†’ OD
  xâˆ‹minimal : (x : OD  ) â†’ ( ne : Â¬ (x == odâˆ… ) ) â†’ def x ( odâ†’ord ( minimal x ne ) )
  minimal-1 : (x : OD  ) â†’ ( ne : Â¬ (x == odâˆ… ) ) â†’ (y : OD ) â†’ Â¬ ( def (minimal x ne) (odâ†’ord y)) âˆ§ (def x (odâ†’ord  y) )

We can avoid this using Îµ-induction (a predicate is valid on all set if the predicate is true on some element of set).
Assuming law of exclude middle, they say axiom of regularity will be proved, but we haven't check it yet.

    Îµ-induction : { Ïˆ : OD  â†’ Set (suc n)}
       â†’ ( {x : OD } â†’ ({ y : OD } â†’  x âˆ‹ y â†’ Ïˆ y ) â†’ Ïˆ x )
       â†’ (x : OD ) â†’ Ïˆ x

In our model, we assumes the mapping between Ordinals and OD, this is actually the TransFinite induction in Ordinals.

The axiom of choice in the book is complicated using any pair in a set, so we use use a form in the Wikipedia.

     âˆ€ X [ âˆ… âˆ‰ X â†’ (âˆƒ f : X â†’ â‹ƒ X ) â†’ âˆ€ A âˆˆ X ( f ( A ) âˆˆ A ) ]

We can formulate like this.

     choice-func : (X : ZFSet ) â†’ {x : ZFSet } â†’ Â¬ ( x â‰ˆ âˆ… ) â†’ ( X âˆ‹ x ) â†’ ZFSet
     choice : (X : ZFSet  ) â†’ {A : ZFSet } â†’ ( Xâˆ‹A : X âˆ‹ A ) â†’ (not : Â¬ ( A â‰ˆ âˆ… )) â†’ A âˆ‹ choice-func X not Xâˆ‹A

It does not requires âˆ… âˆ‰ X .

--Axiom of choice and Law of Excluded Middle

In our model, since OD has a mapping to Ordinals, it has evident order, which means well ordering theorem is valid,
but it don't have correct form of the axiom yet. They say well ordering axiom is equivalent to the axiom of choice,
but it requires law of the exclude middle.

Actually, it is well known to prove law of the exclude middle from axiom of choice in intuitionistic logic, and we can
perform the proof in our mode. Using the definition like this, predicates and ODs are related and we can ask the
set is empty or not if we have an axiom of choice, so we have the law of the exclude middle  p âˆ¨ ( Â¬ p ) .

    ppp :  { p : Set n } { a : OD  } â†’ record { def = Î» x â†’ p } âˆ‹ a â†’ p
    ppp  {p} {a} d = d

We can prove axiom of choice from law excluded middle since we have TransFinite induction. So Axiom of choice
and Law of Excluded Middle is equivalent in our mode.

--Relation-ship among ZF axiom

<center><img src="fig/axiom-dependency.svg"></center>

--Non constructive assumption in our model

mapping between OD and Ordinals

  odâ†’ord : OD  â†’ Ordinal
  ordâ†’od : Ordinal  â†’ OD
  oiso   :  {x : OD }      â†’ ordâ†’od ( odâ†’ord x ) â‰¡ x
  diso   :  {x : Ordinal } â†’ odâ†’ord ( ordâ†’od x ) â‰¡ x
  c<â†’o<  :  {x y : OD  }   â†’ def y ( odâ†’ord x ) â†’ odâ†’ord x o< odâ†’ord y

Equivalence on OD

  ==â†’oâ‰¡ : { x y : OD  } â†’ (x == y) â†’ x â‰¡ y

Upper bound

  sup-o  :  ( Ordinal  â†’ Ordinal ) â†’  Ordinal
  sup-o< :  { Ïˆ : Ordinal  â†’  Ordinal } â†’ âˆ€ {x : Ordinal } â†’ Ïˆ x  o<  sup-o Ïˆ

Axiom of choice and strong axiom of regularity.

  minimal : (x : OD  ) â†’ Â¬ (x == odâˆ… )â†’ OD
  xâˆ‹minimal : (x : OD  ) â†’ ( ne : Â¬ (x == odâˆ… ) ) â†’ def x ( odâ†’ord ( minimal x ne ) )
  minimal-1 : (x : OD  ) â†’ ( ne : Â¬ (x == odâˆ… ) ) â†’ (y : OD ) â†’ Â¬ ( def (minimal x ne) (odâ†’ord y)) âˆ§ (def x (odâ†’ord  y) )

--So it this correct?

Our axiom are syntactically the same in the text book, but negations are slightly different.

If we assumes excluded middle, these are exactly same.

Even if we assumes excluded middle, intuitionistic logic itself remains consistent, but we cannot prove it.

Except the upper bound, axioms are simple logical relation.

Proof of existence of mapping between OD and Ordinals are not obvious. We don't know we prove it or not.

Existence of the Upper bounds is a pure assumption, if we have not limit on Ordinals, it may contradicts,
but we don't have explicit upper limit on Ordinals.

Several inference on our model or our axioms are basically parallel to the set theory text book, so it looks like correct.

--How to use Agda Set Theory

Assuming record ZF, classical set theory can be developed. If necessary, axiom of choice can be
postulated or assuming law of excluded middle.

Instead, simply assumes non constructive assumption, various theory can be developed. We haven't check
these assumptions are proved in record ZF, so we are not sure, these development is a result of ZF Set theory.

ZF record itself is not necessary, for example, topology theory without ZF can be possible.

--Topos and Set Theory

Topos is a mathematical structure in Category Theory, which is a Cartesian closed category which has a
sub-object classifier. 

Topos itself is model of intuitionistic logic. 

Transitive Sets are objects of Cartesian closed category.
It is possible to introduce Power Set Functor on it

We can use replacement A âˆ© x for each element in Transitive Set,
in the similar way of our power set axiom. I

A model of ZF Set theory can be constructed on top of the Topos which is shown in Oisus. 

Our Agda model is a proof theoretic version of it.

--Cardinal number and Continuum hypothesis

Axiom of choice is required to define cardinal number

definition of cardinal number is not yet done

definition of filter is not yet done

we may have a model without axiom of choice or without continuum hypothesis

Possible representation of continuum hypothesis is this.

     continuum-hyphotheis : (a : Ordinal) â†’ Power (Ord a) âŠ† Ord (osuc a)

--Filter

filter is a dual of ideal on boolean algebra or lattice. Existence on natural number
is depends on axiom of choice.

    record Filter  ( L : OD  ) : Set (suc n) where
       field
           filter : OD
           proper : Â¬ ( filter âˆ‹ odâˆ… )
           inL :  filter âŠ† L 
           filter1 : { p q : OD } â†’  q âŠ† L  â†’ filter âˆ‹ p â†’  p âŠ† q  â†’ filter âˆ‹ q
           filter2 : { p q : OD } â†’ filter âˆ‹ p â†’  filter âˆ‹ q  â†’ filter âˆ‹ (p âˆ© q)

We may construct a model of non standard analysis or set theory.

This may be simpler than classical forcing theory ( not yet done).

--Programming Mathematics

Mathematics is a functional programming in Agda where proof is a value of a variable. The mathematical
structure are

   record and data

Proof is check by type consistency not by the computation, but it may include some normalization.

Type inference and termination is not so clear in multi recursions.

Defining Agda record is a good way to understand mathematical theory, for examples,

    Category theory ( Yoneda lemma, Floyd Adjunction functor theorem, Applicative functor )
    Automaton ( Subset constructionã€Language containment)

are proved in Agda.

--link

Summer school of foundation of mathematics (in Japanese)
<br> <a href="https://www.sci.shizuoka.ac.jp/~math/yorioka/ss2019/">
https://www.sci.shizuoka.ac.jp/~math/yorioka/ss2019/
</a>

Foundation of axiomatic set theory (in Japanese)
<br> <a href="https://www.sci.shizuoka.ac.jp/~math/yorioka/ss2019/sakai0.pdf">
https://www.sci.shizuoka.ac.jp/~math/yorioka/ss2019/sakai0.pdf
</a>

Agda
<br> <a href="https://agda.readthedocs.io/en/v2.6.0.1/">
https://agda.readthedocs.io/en/v2.6.0.1/
</a>

ZF-in-Agda source
<br> <a href="https://github.com/shinji-kono/zf-in-agda.git">
https://github.com/shinji-kono/zf-in-agda.git
</a>

Category theory in Agda source
<br> <a href="https://github.com/shinji-kono/category-exercise-in-agda">
https://github.com/shinji-kono/category-exercise-in-agda
</a>



